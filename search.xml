<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Map的内部结构]]></title>
      <url>/2017/05/06/java-map/</url>
      <content type="html"><![CDATA[<h3 id="常用的Map实现类"><a href="#常用的Map实现类" class="headerlink" title="常用的Map实现类"></a>常用的Map实现类</h3><p>常见的Map实现类大概简单地列举几个。</p>
<ul>
<li>java.util.HashMap</li>
<li>java.util.LinkedHashMap</li>
<li>java.util.concurrent.ConcurrentHashMap</li>
<li>java.util.concurrent.ConcurrentSkipListMap</li>
<li>java.util.IdentityHashMap</li>
<li>java.util.TreeMap</li>
<li>java.util.Hashtable</li>
<li>org.springframework.util.ConcurrentReferenceHashMap</li>
<li>org.springframework.core.annotation.AnnotationAttributes extends LinkedHashMap</li>
<li>org.springframework.ui.ModelMap extends LinkedHashMap</li>
<li>com.mysql.jdbc.util.LRUCache extends LinkedHashMap</li>
</ul>
<p><img src="/images/map-structure.jpg" alt=""></p>
<h3 id="各种Map的数据结构，特点"><a href="#各种Map的数据结构，特点" class="headerlink" title="各种Map的数据结构，特点"></a>各种Map的数据结构，特点</h3><ul>
<li>HashMap基于单向链表数组存储数据，默认容积16，但是在数组上并没有按照数组下标顺序存储，而是按Key的哈希值计算在数组中的位置。</li>
<li>LinkedHashMap基于双向链表存储数据。</li>
<li>IdentityHashMap并不是常用的类，但也还是说一下，它基于Object数组存储，默认容积32，实例化时容积会在默认容积*2(64)，因为Key进行哈希后指定坐标位置存储，然后紧接着下个下标元素会存储对应的value；扩容算法为乘以2；另一个特点，它key在取哈希的时候是用的Object的原始算法，因此，只要KEY是不同的对象，内存地址不相同就可以存入两个相同内容的KEY,也就是Key可以重复。</li>
<li>TreeMap基于二叉树结构。左孩子节点存放比根节点小的，右孩子节点存放比根节点大的数据。</li>
</ul>
<h3 id="有趣的设计"><a href="#有趣的设计" class="headerlink" title="有趣的设计"></a>有趣的设计</h3><ul>
<li>接口中又定义了接口， Map.Entry</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>由于是尝试分析，非常地浅显，欢迎各路大神对文中错误提出指正，对不足之处不吝赐教。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LinkedList和ArrayList的比较]]></title>
      <url>/2017/05/03/java-linked-array-diff/</url>
      <content type="html"><![CDATA[<p>说明：本文所参照的源码是jdk1.8</p>
<h5 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h5><p><img src="/images/hierarchy-linkedlist-arraylist.png" alt=""></p>
<h5 id="List接口提供的方法-28个"><a href="#List接口提供的方法-28个" class="headerlink" title="List接口提供的方法(28个)"></a>List接口提供的方法(28个)</h5><p><img src="/images/methods-in-list.png" alt=""></p>
<a id="more"></a>
<h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><hr>
<ul>
<li>都可被克隆和序列化，且都实现了List接口中定义的方法</li>
<li>实现了相同的hashcode算法</li>
<li>实现了相同的toString方法</li>
</ul>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><hr>
<ul>
<li>数据结构不同</li>
</ul>
<blockquote>
<p>ArrayList是数组数据结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * The array buffer into which the elements of the ArrayList are stored.</div><div class="line">     * The capacity of the ArrayList is the length of this array buffer. Any</div><div class="line">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</div><div class="line">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div></pre></td></tr></table></figure></p>
<p>LinkedList是链表结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>数据初始内存大小和插入性能不同</li>
</ul>
<blockquote>
<p>ArrayList内部数组扩展大小的算法（当前元素数组长度+它的二分之一，如，当前为30，扩展一次则变为45=30+30/2）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Increases the capacity to ensure that it can hold at least the</div><div class="line"> * number of elements specified by the minimum capacity argument.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>ArrayList初始创建时大小也为0（但可以通过构造方法指定大小），但是当往ArrayList中任意添加元素它的大小则会改变，当元素个数小于10则为10，当元素个数大于10，则按照扩展算法进行扩展；<br>LinkedList初始创建大小为0，因为数据结构是链表所以没有指定大小的构造函数。<br><strong>因此</strong>，插入数据从性能上讲，LinkedList比ArrayList好，因为，LinkedList添加元素只要改变链表的前，后节点关系即可，而ArrayList要先检查数组大小处理扩展逻辑和拷贝数据到新的数组。</p>
</blockquote>
<ul>
<li>访问元素的性能对比</li>
</ul>
<blockquote>
<p>ArrayList通过数组下标访问，速度很快；LinkedList则有可能需要遍历整个链表一半的元素才能找到想要的元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the (non-null) Node at the specified element index.</div><div class="line"> */</div><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>LinkedList可实现队列</li>
</ul>
<blockquote>
<p>LinkedList实现了Deque接口，提供诸如push,pop,offer等方法，因此，它能很好地实现队列操作；而ArrayList并没有提供这些方法，由于它的数据结构决定了它也不适合作队列。</p>
</blockquote>
<h5 id="引申分析Vector"><a href="#引申分析Vector" class="headerlink" title="引申分析Vector"></a>引申分析Vector</h5><ul>
<li><p>Vector从实现结构上跟ArrayList是一样的，区别在于Vector是线程安全的，ArrayList则不是。</p>
</li>
<li><p>Vector可以获取容积大小，而ArrayList获取不了</p>
</li>
</ul>
<h5 id="引申分析Set"><a href="#引申分析Set" class="headerlink" title="引申分析Set"></a>引申分析Set</h5><ul>
<li>HashSet为数据结构为HashMap,因此，数据元素不会重复，也没有顺序</li>
<li>LinkedHashSet的数据结构则为LinkedHashMap, 因此，数据元素依然不会重复，但双向链表就可以实现有序了</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[StringBuffer和StringBuilder比较]]></title>
      <url>/2017/05/02/java-buffer-build-diff/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;这个问题其实是很多面试官喜欢问的问题，大多数童鞋都知道它们的主要区别是StringBuffer是线程安全的，StringBuilder非线程安全，因为如此，StringBuilder性能略比StringBuffer好。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我主要从它俩的源码出发来分析它们的区别。</p>
<h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><blockquote>
<p>1.它俩都继承自抽象类AbstractStringBulder，实现了Appendable, CharSequece,Serializable接口，而且都是final类型，跟String类一样不能再有子类扩展了<br>2.它们的内部数据结构都是字符数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The value is used for character storage.</div><div class="line"> */</div><div class="line"><span class="keyword">char</span>[] value;</div></pre></td></tr></table></figure></p>
<p>3.它们默认的创建时的长度为16个字符<br>4.append/delete/insert/replace方法的核心操作都是通过System.arraycopy实现<br>5.它们都提供四个构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBxxx</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBxxx</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBxxx</span><span class="params">(String str)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBxxx</span><span class="params">(CharSequece seq)</span></span>;</div></pre></td></tr></table></figure></p>
<p>6.每当append方法执行前，都会判断数组大小是否足够，如果不够则扩展其长度，算法为 <strong>当前容量长度*2+2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * This method has the same contract as ensureCapacity, but is</div><div class="line">    * never synchronized.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</div><div class="line">       <span class="comment">// overflow-conscious code</span></div><div class="line">       <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</div><div class="line">           expandCapacity(minimumCapacity);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * This implements the expansion semantics of ensureCapacity with no</div><div class="line">    * size check or synchronization.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> newCapacity = value.length * <span class="number">2</span> + <span class="number">2</span>;</div><div class="line">       <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)</div><div class="line">           newCapacity = minimumCapacity;</div><div class="line">       <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;</div><div class="line">           <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">           newCapacity = Integer.MAX_VALUE;</div><div class="line">       &#125;</div><div class="line">       value = Arrays.copyOf(value, newCapacity);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</blockquote>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><blockquote>
<p>1.StringBuffer中方法都是synchronized的，保证线程安全<br>2.StringBuffer多一个toStringCache对象，当StringBuffer有toString方法执行时，就会缓存在这里，当内部数据发生变化就会清除缓存内容<br>3.StringBuilder从JDK1.5才开始有，而StringBuffer从JDK1.0就开始有了</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[服务器监控工具-netdata-搭建]]></title>
      <url>/2017/04/27/netdata/</url>
      <content type="html"><![CDATA[<h3 id="netdata简介"><a href="#netdata简介" class="headerlink" title="netdata简介"></a>netdata简介</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这是个开源项目，项目介绍WIKI：<a href="https://github.com/firehol/netdata/wiki" target="_blank" rel="external">https://github.com/firehol/netdata/wiki</a><br>&nbsp;&nbsp;&nbsp;&nbsp;我已经使用这套监控系统一段时间了，感觉很不错，监控指标丰富，界面美观，能监控集群下的所有节点服务器，它是个什么东东呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;”netdata is a scalable, distributed, real-time, performance and health monitoring solution for Linux, FreeBSD and MacOS. It is open-source too.”</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;netdata是一个可扩展的，分布式的，实时的，为Linux, FreeBSD和MacOS性能及健康状态监控的解决方案，当然它也是开源的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;它可以监控服务器的健康运行参数及状态，包括CPU,内存，网络，磁盘等常用的监控指标，以及自己配置扩展监控项，如，redis, tomcat, mysql, nginx, elasticsearch等，是不是已经觉得很不错了？那接下来我说说我是怎么安装的，怎么配置的吧。</p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><ul>
<li><p>下载</p>
<blockquote>
<p>由于开源项目，直接克隆一套源代码到YOUR_SERVER/path/to/</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/firehol/netdata.git</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>安装</p>
<blockquote>
<p>1.安装编译所需要的包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install zlib-devel libuuid-devel libmnl-devel gcc make git autoconf autogen automake pkgconfig</div></pre></td></tr></table></figure>
<p>2.运行自带的安装启动脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./netdata-installer.sh</div></pre></td></tr></table></figure>
<p>完事你会看到如下提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">It will be installed at these locations:</div><div class="line">  - the daemon     at /usr/sbin/netdata</div><div class="line">  - config files   in /etc/netdata</div><div class="line">  - web files      in /usr/share/netdata</div><div class="line">  - plugins        in /usr/libexec/netdata</div><div class="line">  - cache files    in /var/cache/netdata</div><div class="line">  - db files       in /var/lib/netdata</div><div class="line">  - log files      in /var/log/netdata</div><div class="line">  - pid file       at /var/run/netdata.pid</div><div class="line">  - logrotate file at /etc/logrotate.d/netdata</div><div class="line"> This installer allows you to change the installation path.</div><div class="line"> Press Control-C and run the same command with --help for help.</div><div class="line"> Press ENTER to build and install netdata to your system &gt;</div></pre></td></tr></table></figure>
<p>这些是告诉你，所涉及的文件都安装在哪个目录下，到时配置或修改的时候直接去这些地方找就好了，当然自己也可以仔细看看这些配置文件，了解各个参数的含义。<br>那么这个时候其实就可以通过提示的URL <a href="http://this.machine.ip:19999/" target="_blank" rel="external">http://this.machine.ip:19999/</a> 开始监控当前服务器了, 没错，正如访问地址，默认WEB使用的端口为19999.<br>看看netdata监控界面长啥样儿吧~</p>
<a id="more"></a>
<p><img src="/images/netdata-monitor.png" alt=""></p>
<p>3.修改默认端口和限制仅内网访问<br>为了安全，特别是在生产服务器上，尽量修改掉默认端口，而且我也不想把我的所有服务器的公网IP都公开暴露，所以我会找一个跳板机来监控它们，而且我还限制了netdata的数据只有通过跳板机提供的接口能才访问监控WEB页面，保护集群服务器各个节点，具体修改其实很简单，修改配置文件即可，/etc/netdata/netdata.conf。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[web]</div><div class="line">        <span class="comment"># web files owner = netdata</span></div><div class="line">        <span class="comment"># web files group = netdata</span></div><div class="line">        <span class="comment"># listen backlog = 100</span></div><div class="line">        <span class="comment"># default port = 19999</span></div><div class="line">        <span class="comment"># bind to = *</span></div><div class="line">        <span class="comment"># mode = multi-threaded</span></div><div class="line">        <span class="comment"># disconnect idle clients after seconds = 60</span></div><div class="line">        <span class="comment"># respect do not track policy = no</span></div><div class="line">        <span class="comment"># x-frame-options response header = </span></div><div class="line">        <span class="comment"># enable gzip compression = yes</span></div><div class="line">        <span class="comment"># gzip compression strategy = default</span></div><div class="line">        <span class="comment"># gzip compression level = 3</span></div><div class="line">        default port = 123232</div><div class="line">        <span class="built_in">bind</span> to = 10.xx.yy.zz:123232</div></pre></td></tr></table></figure>
<p>可以看到最后两项是我自己修改的内容，内网的IP，通过ifconfig可以方便地看到，eth0 对应的inet addr就是。<br>修改好了，需要重启一下netdata服务，方法有几种，安装成功注册到service的，可以通过service netdata restart来重启，也可以直接killall netdata, 然后 netdata启动。</p>
<p><strong>这四个步骤重复在所有的服务器上搞一遍，那么基本安装配置就好了，接下来配置Nginx</strong></p>
</blockquote>
</li>
<li><p>访问接口配置</p>
<blockquote>
<p>我使用nginx来配置对外提供的监控访问接口，我选择一台测试服务器，安全要求较低的服务器作为了跳板监控机。Nginx安装此处不细说，介绍一下我配置的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  www.jinsk.vip;</div><div class="line"></div><div class="line">    location /m/1/ &#123;</div><div class="line">        proxy_pass http://10.xx.yy.z1:port/;</div><div class="line">        proxy_set_header        Host <span class="variable">$host</span>;</div><div class="line">        proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line">        proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /m/2/ &#123;</div><div class="line">        proxy_pass http://10.xx.yy.z2:port/;</div><div class="line">        proxy_set_header        Host <span class="variable">$host</span>;</div><div class="line">        proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line">        proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /m/3/ &#123;</div><div class="line">        proxy_pass http://10.xx.yy.z3:port/;</div><div class="line">        proxy_set_header        Host <span class="variable">$host</span>;</div><div class="line">        proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line">        proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /m/4/ &#123;</div><div class="line">        proxy_pass http://10.xx.yy.z4:port/;</div><div class="line">        proxy_set_header        Host <span class="variable">$host</span>;</div><div class="line">        proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line">        proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>基本监控功能模块安装和配置就已经好了，就可以让开发运维的小伙伴们定期的去遛一遍服务器，当然netdata身也是带有提醒功能的，只要你开启着监控页面，就会在设定的预警参数触发和恢复时在浏览器右上角提醒您。</p>
</li>
</ul>
<h3 id="配置redis监控"><a href="#配置redis监控" class="headerlink" title="配置redis监控"></a>配置redis监控</h3><p>按照官方提供的方法，分为Python版和shell版，官方推荐使用python版，所以我按照python版本的方法进行配置的。</p>
<ul>
<li>1.启用redis监控功能，默认是没有启用的<blockquote>
<p>修改/etc/netdata/python.d.conf配置文件中的redis启动项，即去掉注释 #redis: yes<br>redis: yes</p>
</blockquote>
</li>
<li>2.配置redis的地址，端口，用户名，密码<blockquote>
<p>修改/etc/netdata/python.d/redis.conf配置文件<br>支持socket, ipv4, ipv6方式,参考已有配置格式进个添加修改即可，先定义个标签，如”basedata_ipv4:”,然后包含四个参数可配置，name,host,port,pass，name就是在监控面板中看到的名称，便于区分多个redis节点，host,port,pass一看就明白分别对应的是什么了，不多说了。</p>
</blockquote>
</li>
</ul>
<h3 id="配置mysql监控"><a href="#配置mysql监控" class="headerlink" title="配置mysql监控"></a>配置mysql监控</h3><p>有了上面的redis插件配置方法，配置mysql就是依葫芦画瓢了，先去掉#mysql:yes的注释，然后配置mysql.conf中的连接参数。</p>
<h3 id="配置tomcat监控"><a href="#配置tomcat监控" class="headerlink" title="配置tomcat监控"></a>配置tomcat监控</h3><p>目前我是还没有配置，因为，我生产应用的tomcat改造过，并且移除了status模块，所以暂时还没有配置集中监控功能。</p>
<h3 id="配置nginx监控"><a href="#配置nginx监控" class="headerlink" title="配置nginx监控"></a>配置nginx监控</h3><p>目前我也还没有配置，网上资料挺多的，安装相应模块，并配置相应的参数即可应用了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>优点<blockquote>
<p>1.极大的方便了监控服务器的操作，可以让团队的小伙伴们一起来做这事，而且还可以在家里做，随时随地做，再也不需要指定小伙伴登录CRT去逐个服务器检查了。<br>2.由于本身提供的监控指标够多，也有相对较合理的预警值提醒，因此，只要打开着监控页面，看到有报警去对应处理就可以了，提高了工作效率。</p>
</blockquote>
</li>
<li>建议<blockquote>
<p>1.配置需要仔细小心，当时绑定内网IP的时候，我就不小心小手一抖把bind to 写成了 bing to, 因此而测试了好久没找到原因，一度还怀疑netdata功能有问题，于是乎，我还去github提了<a href="https://github.com/firehol/netdata/issues/2067" target="_blank" rel="external">issue</a>。<br>2.观察日志，有没有出现异常。<br>3.去github上搜索解决方案，你遇到的问题别人早就遇到过了，而且已经解决了。</p>
</blockquote>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的博客小窝上线了]]></title>
      <url>/2017/04/21/first/</url>
      <content type="html"><![CDATA[<h3 id="本窝目的"><a href="#本窝目的" class="headerlink" title="本窝目的"></a>本窝目的</h3><p>作为一名程序猿，应该要有自己的小窝来总结、积累、沉淀自己的东西，充实自己，因此，趁在农忙过后的这段时间搭好环境，转移曾经的笔记到这个小窝来。<br>随便回顾一下本博所搭建运用的技术，因此也是我需要学习的新知识，如：markdown语法， hexo框架，github管理及git工具。</p>
<h3 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h3><ul>
<li>Github<blockquote>
<p><a href="https://github.com/" target="_blank" rel="external">注册帐号</a><br>创建项目</p>
</blockquote>
</li>
<li>本地搭建hexo环境<blockquote>
<p>安装Node.js<br>安装hexo<br>创建博客项目<br>配置github帐号<br>安装插件<br><a href="https://hexo.io/themes/" target="_blank" rel="external">选择主题</a><br>下载并配置主题（本人选择了<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external">icarus</a>）</p>
</blockquote>
</li>
<li>安装Markdown环境<blockquote>
<p>安装SublimeText3<br>安装Markdown插件</p>
</blockquote>
</li>
</ul>
<h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><h6 id="上面各个步骤在网上都有很多资料，对照着配置都不会有什么问题，但我简单把我遇到的问题并且在网上并没有找到太多资料的步骤描述一下，方便遇到和我一样问题的朋友可以借鉴。"><a href="#上面各个步骤在网上都有很多资料，对照着配置都不会有什么问题，但我简单把我遇到的问题并且在网上并没有找到太多资料的步骤描述一下，方便遇到和我一样问题的朋友可以借鉴。" class="headerlink" title="上面各个步骤在网上都有很多资料，对照着配置都不会有什么问题，但我简单把我遇到的问题并且在网上并没有找到太多资料的步骤描述一下，方便遇到和我一样问题的朋友可以借鉴。"></a>上面各个步骤在网上都有很多资料，对照着配置都不会有什么问题，但我简单把我遇到的问题并且在网上并没有找到太多资料的步骤描述一下，方便遇到和我一样问题的朋友可以借鉴。</h6><a id="more"></a>
<ul>
<li><p>主题汉化</p>
<blockquote>
<p>1.下载就略过了，git clone 对应的主题到本地themes目录下<br>2.我一开始还对主题的各个页面进行了汉化修改，但实际上并不需要，只要把主配置文件_config.yml中语言项配置为zh-CN即可，即(language: zh-CN)</p>
</blockquote>
</li>
<li><p>自定义域名配置</p>
<blockquote>
<p>如果你也和我一样，专门申请了一个专用的域名，那么会在github中配置costom domain,但是每次重新发布之后，又需要重新设置<br><strong>解决办法</strong>：在项目source目录中创建CNAME文件，在里面写上自己的域名即可，再重新发即不需要重新设置了</p>
</blockquote>
</li>
<li><p>评论支持功能配置</p>
<blockquote>
<p>1.社会化评论系统选择，我首先参考了网上很多朋友使用的友言，我开始配置了，发现发布github上之后，提交评论时提示参数不正确，无法提交评论内容，于是，转而尝试多说，但是遗憾多说将在6.1日关停评论服务，所以，后来我选择了”<a href="http://changyan.kuaizhan.com/" target="_blank" rel="external">搜狐畅言</a>“<br>2.对于畅言来说，配置还是挺简单的，注册好帐号就能找到appid和conf两个东西，配置上就OK了<br>3.配置主题中_config.yml-&gt;comment: changyan: 两项，并不需要网上所说修改artcle.ejs了，因为，新版的主题直接在最下边处理好了,在index.ejs中针对支持的评论系统做好了处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%- partial(&apos;comment/index&apos;) %&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>分类和标签通过菜单进入无内容显示</p>
<blockquote>
<p><strong>解决办法</strong>：把主题下面边的categories里的index.md复制到项目的source里categories目录里的index.md进行替换，其实也就是参考主题里的写法就好了；标签的也一样。</p>
</blockquote>
</li>
</ul>
<h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>希望大家多多指教，多多交流，左边二维码是我的微信，欢迎加我好友进行交流，相互学习。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> 随笔日志 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
